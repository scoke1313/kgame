<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ë‘¥ë‘¥ê·¸ë¼ìš´ë“œ: íˆ¬ëª…í™” ì™„ì „ í•´ê²°</title>
    <style>
        @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');
        body { margin: 0; padding: 0; background-color: #333; font-family: 'Pretendard', sans-serif; overflow: hidden; touch-action: none; user-select: none; display: flex; justify-content: center; align-items: center; height: 100vh; }
        #game-wrapper { position: relative; width: 100%; max-width: 500px; height: 100%; max-height: 900px; background: linear-gradient(to bottom, #4FABFF 0%, #89CFF0 60%, #8BC34A 100%); overflow: hidden; box-shadow: 0 0 30px rgba(0,0,0,0.5); }
        
        canvas { 
            display: block; width: 100%; height: 100%;
            -webkit-tap-highlight-color: transparent;
        }

        .ui-top { position: absolute; top: 0; left: 0; width: 100%; padding: 15px 20px; box-sizing: border-box; display: flex; justify-content: space-between; align-items: flex-start; pointer-events: none; z-index: 10; }
        .hud-box { background: rgba(0, 0, 0, 0.5); color: #fff; padding: 8px 16px; border-radius: 20px; font-size: 16px; font-weight: bold; display: flex; flex-direction: column; align-items: center; backdrop-filter: blur(4px); border: 1px solid rgba(255,255,255,0.2); box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
        .hud-label { font-size: 12px; opacity: 0.8; margin-bottom: 2px; }
        .hud-value { font-size: 24px; color: #fff; text-shadow: 1px 1px 0 #000; }
        #score-box .hud-value { color: #FFD700; font-size: 28px; }
        #center-msg { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: white; width: 100%; pointer-events: none; z-index: 20; text-shadow: 0 2px 5px rgba(0,0,0,0.5); transition: opacity 0.3s; }
        #center-msg h1 { font-size: 40px; margin: 0; color: #FEE500; -webkit-text-stroke: 1px #333; }
        #center-msg p { font-size: 16px; margin-top: 10px; font-weight: 500; line-height: 1.5; }
        #result-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; display: none; animation: fadeIn 0.3s forwards; }
        .card { background: white; width: 85%; padding: 30px; border-radius: 25px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        .score-big { font-size: 56px; font-weight: 900; color: #D1180B; margin: 5px 0 20px 0; }
        .btn { background: #FEE500; border: none; padding: 15px 40px; font-size: 22px; font-weight: bold; border-radius: 30px; cursor: pointer; box-shadow: 0 4px 0 #C9B000; transition: transform 0.1s; }
        #damage-overlay { position: absolute; top:0; left:0; width:100%; height:100%; background: rgba(255, 0, 0, 0.4); opacity: 0; pointer-events: none; z-index: 5; transition: opacity 0.1s; }
        #flash-overlay { position: absolute; top:0; left:0; width:100%; height:100%; background: white; opacity: 0; pointer-events: none; z-index: 6; transition: opacity 0.1s; }
    </style>
</head>
<body>

<div id="game-wrapper">
    <div id="damage-overlay"></div>
    <div id="flash-overlay"></div>
    <div class="ui-top">
        <div class="hud-box">
            <span class="hud-label">ë‚¨ì€ ê±°ë¦¬</span>
            <span class="hud-value" id="alt-display">1500m</span>
        </div>
        <div class="hud-box" id="score-box">
            <span class="hud-label">SCORE</span>
            <span class="hud-value" id="score-display">0</span>
        </div>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="center-msg">
        <h1>TOUCH TO TURN</h1>
        <p>í„°ì¹˜ë¡œ ë°©í–¥ ì „í™˜!<br>ğŸ“¦ìƒìëŠ” ì ìˆ˜ / ğŸ¦ìƒˆëŠ” ê°ì <br>âœ¨<strong>í™©ê¸ˆ ê³ êµ¬ë§ˆëŠ” ëŒ€ë°• ì°¬ìŠ¤!</strong></p>
    </div>
    <div id="result-screen">
        <div class="card">
            <h2>ì‘ì „ ì™„ë£Œ!</h2>
            <p>ìµœì¢… ì ìˆ˜</p>
            <div class="score-big" id="res-score">0</div>
            <button class="btn" onclick="resetGame()">ë‹¤ì‹œ ë„ì „</button>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const elAlt = document.getElementById('alt-display');
    const elScore = document.getElementById('score-display');
    const elMsg = document.getElementById('center-msg');
    const elResult = document.getElementById('result-screen');
    const elResScore = document.getElementById('res-score');
    const elDamage = document.getElementById('damage-overlay');
    const elFlash = document.getElementById('flash-overlay');

    const playerImage = new Image();
    playerImage.src = 'dong_chun.png';

    const TOTAL_DISTANCE = 1500; 
    const DESCENT_SPEED = 8;     
    const LATERAL_SPEED = 7;     
    const SPAWN_INTERVAL = 2; 
    
    let gameState = 'READY'; 
    let distance = TOTAL_DISTANCE;
    let score = 0;
    let playerDir = 1; 
    let frameCount = 0;
    let objects = []; 
    let clouds = [];
    let floatingTexts = []; 
    let shakeTimer = 0; 

    function resize() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
    }
    window.addEventListener('resize', resize);
    resize();

    const wrapper = document.getElementById('game-wrapper');
    const handleInput = (e) => {
        if(e.cancelable) e.preventDefault();
        if(gameState === 'READY') { gameState = 'PLAYING'; elMsg.style.opacity = 0; return; }
        if(gameState === 'PLAYING') { playerDir *= -1; }
    };
    wrapper.addEventListener('mousedown', handleInput);
    wrapper.addEventListener('touchstart', handleInput, {passive: false});

    function spawnCloud(initialY = -100) {
        clouds.push({ x: Math.random() * 500, y: initialY, size: Math.random() * 40 + 40, speedScale: Math.random() * 0.5 + 0.5 });
    }

    function spawnObject() {
        const x = Math.random() * 450 + 25;
        const rand = Math.random();
        let type, visual, value;

        if (rand < 0.01) { type = 'GOLD'; visual = 'ğŸ âœ¨'; value = 500; } 
        else if (rand < 0.76) { type = 'CRATE'; visual = 'ğŸ“¦'; value = 100; } 
        else { type = 'BAD'; visual = Math.random() < 0.5 ? 'ğŸ¦' : 'ğŸš'; value = -200; }

        objects.push({ x: x, y: 950, type: type, visual: visual, value: value, hit: false, scale: 1, transformed: false });
    }

    function showFloatingText(x, y, text, color) {
        floatingTexts.push({ x: x, y: y, text: text, color: color, life: 30, offsetY: 0 });
    }

    function triggerGoldEffect() {
        elFlash.style.opacity = 0.8;
        setTimeout(() => elFlash.style.opacity = 0, 300);
        objects.forEach(obj => {
            if (obj.type === 'BAD' && !obj.hit) {
                obj.type = 'CRATE'; obj.visual = 'ğŸ“¦'; obj.value = 100; obj.scale = 1.5; obj.transformed = true;
                showFloatingText(obj.x, obj.y - 60, "ë³€ì‹ !", "#FFD700");
            }
        });
    }

    function drawPlayer() {
        const rect = canvas.getBoundingClientRect();
        const cx = rect.width / 2;
        const cy = rect.height * 0.25; 
        
        ctx.save();
        if (shakeTimer > 0) { ctx.translate((Math.random()-0.5)*10, (Math.random()-0.5)*10); shakeTimer--; }
        ctx.translate(cx, cy);
        ctx.translate(0, Math.sin(frameCount * 0.1) * 3);
        ctx.rotate(playerDir * 0.15);
        ctx.scale(playerDir, 1);

        const baseSize = 130;
        const imgSize = baseSize * 1.04; 

        if (playerImage.complete) {
            ctx.drawImage(playerImage, -imgSize/2, -imgSize/2, imgSize, imgSize);
        }
        ctx.restore();
    }

    function gameOver() { gameState = 'END'; elResult.style.display = 'flex'; elResScore.innerText = score.toLocaleString(); }

    function resetGame() {
        distance = TOTAL_DISTANCE; playerDir = 1; objects = []; clouds = []; floatingTexts = []; score = 0;
        for(let i=0; i<15; i++) spawnCloud(Math.random() * 900);
        gameState = 'READY'; elResult.style.display = 'none'; elMsg.style.opacity = 1;
        elAlt.innerText = TOTAL_DISTANCE + "m"; elScore.innerText = "0";
        draw();
    }

    function update() {
        if(gameState !== 'PLAYING') return;
        frameCount++;
        distance -= DESCENT_SPEED * 0.05;
        if(distance <= 0) { distance = 0; gameOver(); return; }
        if(frameCount % SPAWN_INTERVAL === 0) spawnObject();
        if(frameCount % 20 === 0) spawnCloud(950);
        const bgMoveX = -playerDir * LATERAL_SPEED * 0.5; 
        clouds.forEach((c, i) => {
            c.y -= DESCENT_SPEED; c.x += bgMoveX * c.speedScale;
            if(c.y < -100) clouds.splice(i, 1);
        });
        const obsMoveX = -playerDir * LATERAL_SPEED;
        const rect = canvas.getBoundingClientRect();
        const px = rect.width / 2;
        const py = rect.height * 0.25;
        objects.forEach((obj, i) => {
            obj.y -= DESCENT_SPEED; obj.x += obsMoveX;
            if(obj.type === 'GOLD' || obj.transformed) { obj.scale = obj.transformed ? obj.scale + (1 - obj.scale) * 0.1 : 1 + Math.sin(frameCount * 0.2) * 0.2; }
            if(obj.y < -100) { objects.splice(i, 1); return; }
            if(!obj.hit) {
                const dx = px - obj.x; const dy = py - obj.y; const dist = Math.sqrt(dx*dx + dy*dy);
                if(dist < 55) {
                    obj.hit = true; score += obj.value; if(score < 0) score = 0;
                    if (obj.type === 'BAD') { shakeTimer = 10; elDamage.style.opacity = 0.6; setTimeout(()=> elDamage.style.opacity = 0, 100); showFloatingText(px, py - 60, "-200", "#FF4444"); }
                    else if (obj.type === 'GOLD') { triggerGoldEffect(); showFloatingText(px, py - 60, "JACKPOT!", "#FFD700"); objects.splice(i, 1); }
                    else { showFloatingText(px, py - 60, "+100", "#8BC34A"); objects.splice(i, 1); }
                }
            }
        });
        floatingTexts.forEach((ft, i) => { ft.life--; ft.offsetY -= 2; if(ft.life <= 0) floatingTexts.splice(i, 1); });
        elAlt.innerText = Math.floor(distance) + "m"; elScore.innerText = score.toLocaleString();
    }

    // â˜…â˜…â˜… ì—¬ê¸°ê°€ í•µì‹¬ ìˆ˜ì •ëœ draw í•¨ìˆ˜ì…ë‹ˆë‹¤ â˜…â˜…â˜…
    function draw() {
        const rect = canvas.getBoundingClientRect();
        // 1. í™”ë©´ ì „ì²´ ì§€ìš°ê¸°
        ctx.clearRect(0, 0, rect.width, rect.height);
        
        // 2. êµ¬ë¦„ ê·¸ë¦¬ê¸° (â˜…ì™„ë²½ ê²©ë¦¬â˜…)
        // save()ì™€ restore()ë¡œ ê°ì‹¸ì„œ íˆ¬ëª…ë„(0.3)ê°€ ì ˆëŒ€ë¡œ ë°–ìœ¼ë¡œ ëª» ë‚˜ê°€ê²Œ ê°€ë‘¡ë‹ˆë‹¤.
        ctx.save(); 
        ctx.globalAlpha = 0.3; // ì—¬ê¸°ì„œë§Œ íˆ¬ëª…í•˜ê²Œ
        ctx.fillStyle = '#ffffff';
        clouds.forEach(c => { 
            ctx.beginPath(); 
            ctx.arc(c.x, c.y, c.size, 0, Math.PI*2); 
            ctx.fill(); 
        });
        ctx.restore(); // ì—¬ê¸°ì„œ íˆ¬ëª…ë„ ì„¤ì • ìë™ íê¸° -> ë‹¤ì‹œ ë¶ˆíˆ¬ëª…(1.0)ìœ¼ë¡œ ë³µêµ¬ë¨

        // 3. ì•„ì´í…œ ê·¸ë¦¬ê¸° (ì´ì œ ë¬´ì¡°ê±´ ì°í•˜ê²Œ ë‚˜ì˜µë‹ˆë‹¤)
        ctx.textAlign = "center"; 
        ctx.textBaseline = "middle";
        ctx.fillStyle = '#000000'; // ê¸°ë³¸ ê²€ì • (ì´ëª¨ì§€ì—” ì˜í–¥ ì—†ì§€ë§Œ ì•ˆì „ì¥ì¹˜)
        
        // ì•ˆì „ì„ ìœ„í•´ globalAlpha ê°•ì œ ì´ˆê¸°í™”
        ctx.globalAlpha = 1.0; 

        objects.forEach(obj => {
            // ë§ì•˜ì„ ë•Œë§Œ ë°˜íˆ¬ëª…í•˜ê²Œ í•˜ê¸° ìœ„í•´ ì—¬ê¸°ì„œë„ ê²©ë¦¬ ì‚¬ìš©
            ctx.save(); 
            
            if(obj.hit && obj.type === 'BAD') {
                ctx.globalAlpha = 0.5;
            } else {
                ctx.globalAlpha = 1.0; // í‰ì†Œì—” 100% ë¶ˆíˆ¬ëª…
            }

            let fontSize = 36;
            if (obj.visual === 'ğŸš') fontSize *= 1.8;
            else if (obj.type === 'BAD') fontSize *= 1.5;
            else fontSize *= 1.15;
            
            // ëª¨ë°”ì¼ íˆ¬ëª… ë²„ê·¸ ë°©ì§€ë¥¼ ìœ„í•´ í°íŠ¸ ë‹¨ìˆœí™” + bold ì œê±°
            ctx.font = `${fontSize * obj.scale}px sans-serif`;
            
            if(obj.type === 'GOLD') { 
                ctx.shadowColor = "#FFD700"; 
                ctx.shadowBlur = 25; 
                ctx.fillText(obj.visual, obj.x, obj.y); 
            } else { 
                // ê·¸ë¦¼ì íš¨ê³¼ ì—†ì´ ê¹”ë”í•˜ê²Œ ì¶œë ¥
                ctx.shadowBlur = 0; 
                ctx.fillText(obj.visual, obj.x, obj.y); 
            }
            
            ctx.restore(); // ì•„ì´í…œ í•˜ë‚˜ ê·¸ë¦´ ë•Œ ì“´ íš¨ê³¼ íê¸°
        });

        // 4. ë°”ë‹¥ ê·¸ë¦¬ê¸°
        if(distance < 150) {
            const gy = rect.height * 0.25 + (distance * 10);
            ctx.fillStyle = '#4CAF50'; 
            ctx.fillRect(0, gy, rect.width, rect.height);
            ctx.font = '60px sans-serif'; 
            ctx.fillText('ğŸ', rect.width*0.5, gy+60);
        }

        // 5. í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸°
        drawPlayer();

        // 6. ì ìˆ˜ í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
        floatingTexts.forEach(ft => { 
            ctx.save(); 
            ctx.globalAlpha = ft.life / 30; 
            ctx.fillStyle = ft.color; 
            ctx.font = "bold 24px Pretendard"; 
            ctx.strokeStyle = "white"; 
            ctx.lineWidth = 3; 
            ctx.strokeText(ft.text, ft.x, ft.y + ft.offsetY); 
            ctx.fillText(ft.text, ft.x, ft.y + ft.offsetY); 
            ctx.restore(); 
        });
    }

    function loop() { update(); draw(); requestAnimationFrame(loop); }
    playerImage.onload = () => { resetGame(); loop(); };
</script>
</body>
</html>
